% !TEX root = ../deviant.tex
\section{Preliminaries}
\label{sec:pre}

Our technique relays on the key concept of \emph{event log}, intending it as a set of observed business process executions, logged into a file in terms of all the occurred events. Each event is related to a specific process \emph{instance}, and describes the occurrence of a well-defined step in the process, namely an \emph{activity}. The logged set of events composing a process instance is addressed as \emph{trace} or \emph{case}. 
From the analysis of the \emph{event log}, we want to extract a Declare \cite{?} \emph{model}\footnote{In this context we'll use \emph{model} to indicate a set of Declare constraints.} of the business process (or refine a preexisting one), able to represent the logged traces in a synthetic way, trough a set of constraints.
In particular, we assume some of the logged traces are \emph{positive}, i.e. they fulfil all the constraints in the business model, whereas others are \emph{negative} in the sense that they diverge from the expected behaviour by violating at least one constraint in the (intended) model. 
We denote with $L^+$ the set of positive traces in the input event log, and with $L^-$ the set of the negative ones.

\paragraph{Language bias} Given a set of Declare templates $D$ and activities $A$, we identify with $D[A]$ the set of all possible grounding of templates in $D$ w.r.t. $A$, i.e. all the constraints that can be built using the given activities.

\paragraph{Logs and traces} We assume that a trace $t$ is a \emph{finite} word over the set of activities (i.e.\ $t\in A^*$), and a log is a \emph{finite} set of traces. The consequences of this choice is that we don't consider parallel events and multiple occurrences of the same trace won't affect our discovery process.\todo{ST: this might be relaxed}

\paragraph{Trace compliance} The role of \emph{compliance} of a trace w.r.t.\ a set of Declare constraints is pivotal in our approach. We assume the standard Declare semantics as detailed in~\cite{???}. Given a trace $t\in A^*$ and a set of constraints $C\subseteq D[A]$, in the following we will use the notation $t\models C$ to indicate that none of the constraints in $C$ are violated in $t$.

\paragraph{Generality of models} The notion of compliance naturally introduces the relation of \emph{generality} (or the converse specificity) between models. We say that a model $M\subseteq D[A]$ is \emph{more general} than $M'\subseteq D[a]$ when for any $t\in A^*$, $t\models M' \Rightarrow t\models M$ (written as $M' \preceq M$ ), and \emph{strictly} more general if there is a $t'\in A^*$ s.t.\ $t'\not\models M'$ and $t'\models M$ (written as $M' \prec M$).

In general, the goal of our technique is to select one, or more, sets of Declare constraints such that all positive traces and none of the negative are compliant.\footnote{The conditions on all the positives and none of the negatives can be relaxed requiring a percentage of them; but this is outside the focus of the present work, and left for future investigation}

A wide body of research has been devoted to techniques to mine declarative process models that characterise a given event log (our positive traces). We are interested in leveraging these techniques and refine those results by taking into account the negative examples as well. To this end we consider a -- possibly empty -- set $P$ of Declare constraints that are known to characterise the positive traces. Such set can be the expression of domain knowledge or the result of a classification-oriented discovery algorithm previously applied to $L^+$. To apply our technique we only require that all the positive traces are compliant with all the constraints in $P$. We are aware of the fact that often this is not guaranteed by state of the art algorithms; in these cases we assume that the positive traces are a subset $L'^+$ of the original $L^+$, that is including only the traces compliant with $P$; i.e.\ $L'^+ = \{ t\in L^+\mid t\models P\}$.

Given the above model $P$, a candidate solution is any subset $S\subseteq D[A]$ s.t.
\begin{enumerate}
  \item $P\subseteq S$,
  \item for all $t\in L^+$ $t\models S$, and
  \item for all $t\in L^-$ $t\not\models S$
\end{enumerate}
Clearly, there can be several sets satisfying these conditions and we need to introduce a notion of \emph{fitness} to identify the preferred ones. 

In some context, \emph{generality} can be the fitness measure, that is we want to identify the set that is less committing in terms of restricting the admitted traces. In some other context on the contrary, we might be interested in the identification of a more \emph{specific} model. So besides allowing all traces in $L^+$ and forbidding all traces in $L^-$, the choice between a general or specific model, obviously affects the classification of the unknown traces.

If we consider generality as the fitness measure then we focus on the subset minimal sets $S$ satisfying the above properties and s.t.\ there is no $S'\subseteq D[A]$ satisfying the properties and strictly more general than $S$ (that is $S\prec S'$).

Although testing for strict generality between two set of constraints is a decidable problem, its worst case complexity makes an exact algorithm unfeasible\todo{ST: here we need a citation}. For this reason we make use of an approximate technique based on comparing the ``deductive'' closure of the candidate models. 
%
To provide an intuition let us consider two possible candidates $S' = \{\mathsf{INIT(a)}\}$ and $S = \{\mathsf{EXISTENCE(a)}\}$. It's easy to see that any trace compliant with $\mathsf{INIT(a)}$ must be compliant also with $\mathsf{EXISTENCE(a)}$, therefore $\{\mathsf{INIT(a), EXISTENCE(a)}\}$ is equivalent to $S'$. If we compare the deductive closure of the two sets we can conclude that $S$ is more general that $S'$.\footnote{Not necessarily \emph{strictly} more general.}

Unfortunately, due to the nature of the Declare language we cannot provide a complete calculus\todo{Here we need more details}, therefore we will resort to a set of \emph{correct} deduction rules; e.g.\ the rules introduced in~\cite{???}. To this end we introduce the notion of a (correct) deductive closure operator\todo{ST: I don't know whether it'a a good name} for the Declare language.

\paragraph{Closure operator} In this context a \emph{deductive closure operator} is a function $cl: \mathcal{P}(D[A])\rightarrow\mathcal{P}(D[A])$ satisfying the properties of extensivity, monotonicity, and idempotence; moreover it should be ``correct'' w.r.t.\ deduction in Declare, that is for any $C\subseteq D[A]$ and $t\in A^*$, $t\models C$ iff $t\models cl(C)$.

Because of the ``correctness'' requirement of $cl$ we can guarantee that for any pair of sets $C, C'\subseteq D[A]$, $cl(C)\subseteq C'$ implies that $C$ is more general than $C'$ ($C'\preceq C$). Unfortunately, we cannot guarantee neither the other way around, nor the strictness. However, the use of specific classes of operators enable the use of off the shelf finite domain optimisers, as we will show in the following section. 

\section{The approach}
\label{sec:approach}

In this section we introduce the actual algorithm based on the closure operator and its implementation. The parameters of the problem are the following
\begin{description}
  \item[$D$] set of Declare templates (language bias)
  \item[$A$] set of activities
  \item[$cl$] closure operator $cl: \mathcal{P}(D[A])\rightarrow\mathcal{P}(D[A])$
  \item[$L^+$] positive traces $L^+ \subseteq A^*$
  \item[$L^-$] negative traces $L^- \subseteq A^*$
  \item[$P$] base model $P\subseteq \{c\in D[A]| \forall t\in L^+\, t\models c\}$
\end{description}

For the sake of modularity and easiness of experimenting with different hypotheses and parameters, we divide our algorithm into two clearly separate stages: the first identifies the candidate constraints, and a second optimisation stage which selects the solutions. However these two steps can be merged into a single monolithic search-based algorithm. The solutions can be further ordered according any preference relation (e.g.\ the smaller solution first).

Starting from the set of all constraints $D[A]$, the first stage identifies for any trace $t$ in $L^-$ the set of constraints for which all traces in $L^+$ are compliant and $t$ is not compliant. The result is therefore a function $choice$ with the domain $L^-$ and co-domain $\mathcal{P}(D[A])$ s.t.:
\begin{subequations}
  \begin{align}
    \bigcup_{t\in L^-} choices(t) \subseteq \{c\in D[A]| \forall t\in L^+ t\models c\} \\
    \forall t\in L^-\quad choices(t)\subseteq \{c\in D[A]| t\not\models c\}
 \end{align}
\end{subequations}

Let $\mathcal{C} = \bigcup_{t\in L^-} choices(t)$ and $\mathcal{S}=\{C\in\mathcal{P}(\mathcal{C})\mid \forall t\in L^-\quad cl(C\cup P)\cap choices(t)\neq \emptyset\}$ be all the subsets of $\mathcal{C}$ that ``violate'' all the negative traces. Then the second (optimisation) stage selects the solutions $S\in \mathcal{S}$ s.t.
\begin{subequations}
  \begin{align}
    \text{there's no $S'\in\mathcal{S}$ s.t. } cl(S'\cup P)\subset cl(S\cup P)\\
    \text{there's no $S'\subset S$ s.t. } cl(S'\cup P)=cl(S\cup P)
  \end{align}
\end{subequations}

We also experimented with an alternative optimisation formulation taking into account cardinality instead of subset relation. The idea is to select the ``minimum causes'' for the rejection of all negative traces. This formulation can be expressed by the properties:
\begin{subequations}
  \begin{align}
    \text{there's no $S'\in\mathcal{S}$ s.t. } |cl(S'\cup P)| < |cl(S\cup P)|\\
    \text{there's no $S'\in\mathcal{S}$ s.t. } |cl(S'\cup P)|=|cl(S\cup P)| \text{ and } |S'| < |S|
  \end{align}
\end{subequations}
The solutions of the ``cardinality-based'' are also ``subset-based'' solutions; but not the other way around, as shown by the following example. For the sake of simplicity let's assume that $P$ is empty and $cl$ is the identity function\footnote{This may also be the case when the constraints selected in the first stage are logically independent.}; consider two negative traces $t_1, t_2$ and a $choice$ function like $\{t_1\mapsto\{c_1, c_2\}, t_1\mapsto\{c_1, c_3\}\}$. The ``subset-based'' solutions are $\{c_1\}, \{c_2, c_3\}$, while $\{c_1\}$ would be the only ``cardinality-based'' solution.

\subsection*{Implementation}

To perform our experiments we decided to separate the implementation of the two stages by reusing as much as possible existing systems.

The first stage is implemented via the ``brute-force'' Algorithm~\ref{alg:cand} that first collects the set of all the constraints that are satisfied by all the positive traces (Line \ref{alg:cand:candidates}). Subsequently, each negative trace is associated (by means of the function ${choices}$) with the subset of those constraints that are not satisfied by the trace  (Line \ref{alg:cand:choices}).
%
\begin{algorithm}
    \caption{Generation of all possible models allowing all traces in $L^+$ and disallowing at least one trace in $L^-$.}
    \label{alg:cand}
    %
    \textbf{Input:}  $D[A], L^+, L^-$\\
    \textbf{Output:} ${compatibles} \subseteq D[A]$, ${choices} : L^- \rightarrow 2^{D[A]}$
	%
	\begin{algorithmic}[1] 
   \Procedure{CandidateGeneration}{$D[A], L^+, L^-$} 
   	\State ${compatibles}= \{c \in D[A] | \forall t \in L^+\, \Call{compliant}{t,c} = \texttt{True}\}$ \label{alg:cand:candidates}
	\For {$t \in L^-$}
		\State ${choices}(t) = \{c \in {compatibles} | \Call{compliant}{t,c} = \texttt{False}\}$\label{alg:cand:choices}
	\EndFor
	\State \Return ${compatibles}, {choices}$
    \EndProcedure
    \end{algorithmic}
\end{algorithm}

The implementation of the compliance verification \textproc{compliant} (i.e.\ $t\models c$) leverages the semantics of Declare patterns defined by means of regular expressions \cite{2017-DiCiccio} to verify the compliance of the traces. It is implemented in Go language employing a regexp implementation that is guaranteed to run in time linear in the size of the input\footnote{For more details, see the Go package regexp documentation at https://golang.org/pkg/regexp/}. 

\lstset{language=Prolog}

The second optimisation stage has been implemented using the \ac{ASP} system \textsc{Clingo}~\cite{DBLP:journals/corr/GebserKKS14}. The main reason for selecting an \ac{ASP} system for finite domain optimisation is that rules provide an effective and intuitive framework to implement a large class of closure operators. In fact, all the deductive systems for Declare that we analysed in the literature (see e.g.~\cite{2016-Bernardi,2017-DiCiccio}) can be recasted as Normal Logic Programs~\cite{2008-Lifschitz} by exploiting the assumption that the set of activities is finite and known in advance.
%
For example the valid formula $\textsc{Init}(a)\implies\textsc{Precedence}(a,b)$ that holds for any pair of activities $a, b$ can be written as the rule
\begin{lstlisting}
  precedence(A,B) :- init(A), activity(B).
\end{lstlisting}
using a specific predicate (\lstinline{activity}) holding the set of activities.

Note that the selection of the optimal stable models does not require the compliance verification on the traces, which are therefore not necessary as input. The required parameters, properly encoded as an \ac{ASP} program, are the closure operator, the base model $P$, and the $choice$ function.

\todo[inline]{ST: I'd drop most of the part below, already described in the preliminaries}

\tododl{nella linea \ref{alg:subsetC} avrei potuto dire $S \subseteq C$ dove $C = \{c \in D[A] ~|~ \exists t \in L^-, c \in {choices}(t)\}$, sarebbe stata un'ottimizzazione, ma non so se sarebbe valida anche per la ricerca del modello massimale}

\begin{algorithm}
    \caption{Selection of the best model according to custom model fitness.}
    \label{alg:select}
    %
    \textbf{Parameters:} $A, {cl}: 2^{D[A]} \rightarrow 2^{D[A]}$\\
    \textbf{Input:}  ${choices} : L^- \rightarrow 2^{D[A]}, P$\\
    \textbf{Output:} $S \subseteq D[A]$
	%
	\begin{algorithmic}[1] 
   \Procedure{Selection}{${choices}, P$} 
  	%\State $C = \{c \in D[A] ~|~ \exists t \in L^-, c \in {choices}(t)\}$
	\State \textbf{select} $S \subseteq \bigcup_{t\in L^-} {choices}(t)$ \textbf{s.t.} \label{alg:subsetC}
	\Indent
		\State 1. $\forall t \in L^-, {choices}(t) \cap {cl}(S \cup P) \neq \varnothing$ 	\label{alg:select:1}
		\State 2. $is\_optimal(S)$									\label{alg:select:2}
		\State 3. $\not\exists S' \subset S ~|~ {cl}(S \cup P) = {cl}(S' \cup P)$		\label{alg:select:3}
	\EndIndent
	\State \Return $S$
    \EndProcedure
    \end{algorithmic}
\end{algorithm}


%The algorithm starts be defining the set $C$ of the constraints allowing all traces in $L^+$ and disallowing at least one trace in $L^-$.

The first condition of Algorithm \ref{alg:select} (Line \ref{alg:select:1}) specifies that $S$ must be a subset of ${compatibles}$ able to discard all traces in $L^-$ as non-compliant.

The second condition (Line \ref{alg:select:2}) accounts for the model fitness function, which can be customized according to the specific needs. For example, we could consider \emph{generality} as a fitness measure. 
%
%Intuitively, a model $M$ is more general than another $M'$ if $M$ allows a superset of the traces accepted by $M'$, i.e. defining ${comp(M)}$ the set of all traces compliant with $M$, $M$ is more general than $M'$---and symmetrically $M'$ is more specific than $M$---if ${comp}(M') \subset {comp}(M)$.\tododl{forse \`e meglio evidenziare questo paragrafo come una definizione?}

%Obviously, testing the generality of a model according to this definition is not feasible, because it requires considering all the allowed/disallowed traces. The closure operator can be employed for such purpose. The two methods (comparing the set of traces compliant with $M$ and $M'$, or comparing their closures ${cl}(M)$ and ${cl}(M)$) are not equivalent because the deductive system deriving from the Declare language is not complete. Nonetheless, as the system is correct, closure operator can be used to identify which model is more general/specific.
%
In that case, we could implement the $is\_optimal(S)$ function as a search for the \emph{minimal} $S$, intending it as the set $S$ of constraints for which there is no $S'$ such that ${cl}(S' \cup P) \subset {cl}(S \cup P)$.

On the other hand, if we want to find the most specific set of constraints---i.e. the model composed of Declare templates in $D$ that excludes the higher number of unknown traces---the $is\_optimal(S)$ operation must be implemented as a search for the \emph{maximal} $S$, intending it as the $S$ for which there is no $S'$ such that ${cl}(S \cup P) \subset {cl}(S' \cup P)$.

Finally, the last selecting condition (Line \ref{alg:select:3}) allows reducing the redundancy of the extracted model. This condition is desirable because---even when the user is interested in the most specific model---redundancy compromises the readability of the solution, without adding any value. Nonetheless, it is important to notice that the condition of Line \ref{alg:select:3} may not be sufficient to completely avoid redundancy because we do not have a complete calculus for the language of conjunction of Declare constraints.

\todo[inline]{ST: end of dropped part}


Even if Algorithm \ref{alg:select} reduces the number of candidate solutions by excluding all those non fulfilling conditions 1., 2., and 3., it is not guaranteed to return a unique solution. If the number of solutions provided by the procedure is too high for human intelligibility, the optimality condition could be further refined by inducing a preference order in the returned solution. For example, one can be interested in being reported first the solutions with the lower number of constraints, or with certain Declare templates. The advantage of our approach is precisely in the possibility to implement off-the-shelves optimisation strategies, where---adapting the $is\_optimal(S)$ function or even the definition of the closure operator---the developer can easily experiment with different model fitness functions.

In order to better clarify the approach, we apply it to a very simple example.  
Consider the sets of positive and negative traces composed by only one trace each: $L^+=\{\textsf{bac}\}$ and $L^-=\{\textsf{ab}\}$. The alphabet of activities is clearly just $A=\{\textsf{a, b, c}\}$. Suppose we want to learn the most general model composed by only the Declare templates $D=\{\textsf{EXISTS, INIT}\}$\tododl{non ho inserito TRUE perch\`e non vorrei confondesse le idee quando si arriva a sceglie il set minimale}.

In this case, the set $D[A]$ can be easily elicited: $D[A]=\{ \textsf{EXISTS(a)}$, $\textsf{EXISTS(b)}$, $\textsf{EXISTS(c)}$, $\textsf{INIT(a)}$, $\textsf{INIT(b)}$, $\textsf{INIT(c)} \}$. Algorithm \ref{alg:cand} elects the following compatible constraints: ${compatibles}=$$\{ \textsf{EXISTS(a)}$, $\textsf{EXISTS(b)}$, $\textsf{EXISTS(c)}$, $\textsf{INIT(b)}\}$, and emits ${choices}(\textsf{ab})=$$\{ \textsf{EXISTS(c)}$, $\textsf{INIT(b)}\}$.

%Algorithm \ref{alg:select} easily computes the set $C$ of all constraints excluding at least one negate traces as $C=$$\{ \textsf{EXISTS(c)}$, $\textsf{INIT(b)}\}$. In this simple case, the subsets of $C$ satisfying the first condition (Line \ref{alg:select:1} of Algorithm \ref{alg:select}) are: $\{\textsf{EXISTS(c)}\}$, $\{\textsf{INIT(b)}\}$, and $\{\textsf{EXISTS(c)}$,$\textsf{INIT(b)}\}$. As we are interested in the most general model, both the solutions $S=$$\{\textsf{EXISTS(c)}\}$ and $S=$$\{\textsf{INIT(b)}\}$ are valid. Note that 

In this simple case, the subsets of ${compatibles}$ satisfying the first condition (Line \ref{alg:select:1}) of Algorithm \ref{alg:select} would be: 
\[
\begin{array}{cl}
 S_1= &  \{\textsf{EXISTS(c)}\}  \\
 S_2= &  \{\textsf{INIT(b)}\}   \\
 S_3= &  \{\textsf{EXISTS(c)}, \textsf{INIT(b)}\} \\
 S_4= & \{\textsf{EXISTS(c)}, \textsf{EXISTS(a)}\} \\
  ... & \\
 S_n= & \{\textsf{EXISTS(c)}, \textsf{INIT(b)}, \textsf{EXISTS(a)}\} \\
 ... &
\end{array}
\]

As we are interested in the most general model, both the solutions $S_1=$ $\{\textsf{EXISTS(c)}\}$ and $S_2=$$\{\textsf{INIT(b)}\}$ are valid. Note that these two solutions cannot be compared according to the definitions of generality or specificity because there exist traces (such as the unknown trace $\textsf{b}$) compliant with $S_2$ and non-compliant with $S_1$, i.e. there is no subset relation between $\mathcal{C}_{S_1}$ and $\mathcal{C}_{S_2}$.

On the contrary, if we are interested in the most specific set of constraints, the ${is\_optimal}(S)$ operation must return the maximal model $\{\textsf{EXISTS(a)}$, $\textsf{EXISTS(b)}$, $\textsf{EXISTS(c)}$, $\textsf{INIT(b)}\}$. Finally, the redundancy check operated by the third selecting condition discards the constraint $\textsf{EXISTS(b)}$, and correctly return the set $S=$$\{\textsf{EXISTS(a)}$, $\textsf{EXISTS(c)}$, $\textsf{INIT(b)}\}$. According to this model, the unknown trace \textsf{b} is negative and \textsf{bca} is positive. 


%
%\tcolor{blue}{**************************}
%
%Therefore, the algorithm is guided by the following schema:
%\begin{outline}
%\1 let the set of constraints ${compatibles}= \{c \in D[A] | \forall t \in L^+ \models c\}$;
%\1 let the function ${choices} : L^- \rightarrow 2^{D[A]}$ be such that ${choices}(t) = \{c \in {compatibles} | t \not\models c\}$;
%\1 search the sets $S \subseteq {compatibles}$ such that both the following conditions are satisfied:
%	\2 $\forall t \in L^-, {choices}(t) \cap {cl}(S \cup P) \neq \varnothing$;
%	\2 $S$ is minimal in the sense that there is no $S'$ such that $ {cl}(S' \cup P) \subset {cl}(S \cup P)$
%\end{outline}
%
%Clearly, any set generated by the algorithm satisfies the conditions 1 and 2 above but it might not be minimal. The requirement of minimality is guided by our need to determine the most general set of constraints.
%However, we also need to guarantee that no solution is missed, i.e., all possible solutions are included in at least one of the sets generated by the algorithm. The advantage of our proposal is that it can be implemented using off-the-shelves optimisation tools (as shown in the section below), where---adapting the closure operator and the optimisation conditions---we can easily experiment with different model fitness functions.
%
%Per ridurre ulteriormente il numero di S in output (oppure per ordinare le soluzioni trovate) potremmo contare gli elementi della closure. oppure puo` essere una preferenza tra template


