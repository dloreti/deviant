% !TEX root = ../deviant-tkde.tex
\section{Conclusion}
\label{sec:concl}
While the vast majority of works see process discovery as a one-class supervised learning task, we embrace the less popular view of process discovery as a binary supervised learning job, where traces representing a ``stranger'' behaviour can be considered as heralds of valuable information about the process itself. Devoted to this vision, we developed a technique which considers both positive and negative traces and performs process discovery as a satisfiability problem, where different heuristics can be adopted to assess the optimal model according to different goals.  

Being able to extract valuable knowledge from negative examples, our proposal \nd can be employed to enrich the process description extracted by a state-of-the-art declarative process discovery algorithm.
%Our work is focused on declarative process models. 
However, it is worth to underline that the resulting declarative process discoverer taking advantage of explicitly defined positive and negative examples would not be necessarily an alternative to procedural discovery techniques. 
Indeed in some cases, when correct thresholds and language biases are adopted, procedural discoverers have the great advantage to provide the user with a rather easy-to-understand definition of the process model. Nonetheless, the informative content provided by those process cases that are discarded by procedural discoverer can still be extremely important. 
For the future, as \nd extracts valuable information from $L^-$ without excluding any trace of $L^+$, it could also be applied as a post processing technique to enrich the output of procedural discoverers with declarative constraints.
%A declarative process discoverer taking advantage of explicitly defined positive and negative examples can extract valuable information from such discarded traces and synthesize it into declarative constraints. 
The resulting output would be an hybrid procedural/declarative process model, showing a simple and handy structured representation of the main business process together with a set of declarative constraints. The goal of such constraints would be to account for less frequent deviances or prohibited behaviours in a much more synthetic and easy-to-understand way with respect to an equivalent spaghetti-like procedural formulation.

Furthermore, such a hybrid solution could also greatly simplifying the elicitation of long-term dependencies between activities that occur at the beginning of the process and those carried out towards the end. Indeed, the structured nature of procedural approaches makes them not properly suitable to express such dependencies.
One current way to tackle such issue is through the employment of global variables and ``if'' statements to control the execution flow of each instance. For example, Kalenkova et al. \cite{2020-Kalenkova} propose a process discovery technique devoted to repair free-choice procedural workflows with additional modelling constructs, which can more easily capture non-local dependencies. Nonetheless, since such additional constraints are intended to preserve the procedural nature of the model, the result may increase its complexity and ultimately affect its readability.
An hybrid procedural/declarative model formulation would maintain a structured form to express the model while integrating it with handy declarative long-term constraints involving activities occurring far from each other in the workflow.
%
%For example, consider the load application process depicted in Fig. ... The procedural nature of the model makes it particularly easy to understand for a human subject. Nonetheless, if we want to add a rather simple constraint such as: "Do not ask customer feedback if the application was cancelled", a substantial modification of the model is required.
%Indeed, the model must state that the branch including "Cancel application" (and then "Notify cancellation") must be followed by the END event, whereas any other branch can still include "Ask for customer feedback" before the END event.
%In practice, adding a constraint of such kind force us to add a alternative branch towards the end of the model.
%If many alternative paths are present in the model and we need to add many conditions of this kind, the diagram in Fig.. may quickly turn into a spaghetti model.
%A more compact and readable way to apply this modification is to maintain the present process model structure and equipping it with a declarative elicitation of the prohibited behaviours. In the considered case, the simple inclusion of a constraint such as "NOT PRECEDENCE(Cancel application, Ask for customer feedback)" prevents all forbidden paths. 
%
This idea of a hybrid procedural/declarative model formulation has been explored by various works and proved to be particularly effective in the field of medical clinical guidelines \cite{2009a-Bottrighi,2009b-Bottrighi, 2011-Bottrighi}. A wider landscape of applications is considered by Maggi et al. in the work \cite{2018b-Maggi}. %The technique starts from a structured business process model and adopts non-deterministic finite-state automaton manipulation to detect violations of compliance requirements expressed as temporal declarative rules.



Finally, the performance of \nd presented in this paper could be boosted through a parallel approach. Analogously to previous works \cite{2018a-Maggi, 2018-Loreti, 2020b-Loreti} we can envisage two possible directions to decompose our task: by spitting the model (i.e. in this case the set of constraints to be learned), or the input data (i.e. the business log). The algorithm presented here could easily adopt the first kind of partitioning, whereas the second might be more challenging.
